{"version":3,"sources":["../../src/constants.js","../../src/options.js","../../src/create-element.js","../../src/component.js","../../src/render.js","../../src/create-context.js","../../src/util.js","../../src/diff/children.js","../../src/diff/props.js","../../src/diff/index.js","../../src/clone-element.js","../../src/diff/catch-error.js","../../src/index.js","../../src/PureComponent.js","../../src/memo.js","../../src/forwardRef.js","../../src/Children.js","../../src/suspense.js","../../src/suspense-list.js","../../src/portals.js","../node_modules/preact/compat/jsx-runtime.mjs","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/smoothscroll-polyfill/dist/smoothscroll.js","../../src/observers.ts","../../src/InView.tsx","../../src/useInView.tsx","../node_modules/intersection-observer/intersection-observer.js"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","createVNode","original","vnode","undefined","constructor","createRef","current","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","toChildArray","out","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","setStyle","style","setProperty","test","dom","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","hydrate","diffProps","checked","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","ctor","handled","wasHydrating","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","getHookState","index","hooks","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","nextValue","action","useEffect","args","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","factory","useCallback","flushAfterPaintEffects","forEach","invokeCleanup","invokeEffect","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","filter","hook","comp","oldArgs","newArgs","arg","f","shallowDiffers","PureComponent","p","memo","comparer","shouldUpdate","nextProps","updateRef","Memoed","displayName","isReactComponent","isPureReactComponent","oldDiffHook","REACT_FORWARD_SYMBOL","Symbol","for","Forwarded","mapFn","fn","map","Children","count","only","normalized","toArray","oldCatchError","detachedClone","effect","removeOriginal","Suspense","_suspenders","suspended","SuspenseList","_next","_map","promise","suspendingVNode","suspendingComponent","resolved","onResolved","onSuspensionComplete","pop","fallback","list","delete","revealOrder","size","ContextProvider","Portal","_this","container","_container","wrap","parent","_temp","_unmount","_wrap","_hasMounted","delegated","get","u","wrappedUnsuspend","unsuspend","Map","reverse","set","REACT_ELEMENT_TYPE","CAMEL_PROPS","ONCHANGE_INPUT_TYPES","Object","defineProperty","configurable","v","writable","oldEventHook","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","classNameDescriptor","class","oldVNodeHook","multiple","selected","className","enumerable","$$typeof","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","element","useImperativeHandle","createHandle","concat","useContext","useDebugValue","formatter","version","textContent","preactRender","preactHydrate","unmountComponentAtNode","createPortal","createFactory","preactCloneElement","apply","findDOMNode","forwardRef","clone","unstable_batchedUpdates","StrictMode","lazy","loader","prom","Lazy","exports","default","_arrayLikeToArray","arr","len","arr2","_slicedToArray","iterator","_arr","_n","_d","_e","_s","_i","next","err","o","minLen","n","toString","from","TypeError","__source","__self","defaults","module","polyfill","w","window","d","documentElement","__forceSmoothScrollPolyfill__","userAgent","Element","HTMLElement","scroll","scrollTo","scrollBy","elementScroll","scrollElement","scrollIntoView","now","performance","Date","ROUNDING_TOLERANCE","navigator","RegExp","join","shouldBailOut","smoothScroll","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","scrollLeft","scrollTop","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","hasScrollableSpace","el","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","host","step","currentX","currentY","k","elapsed","startTime","Math","cos","PI","startX","startY","method","scrollable","ObserverMap","RootIds","rootId","optionsToId","observe","id","instance","elements","observer","IntersectionObserver","entries","inView","entry","thresholds","createObserver","callbacks","isPlainChildren","InView","_unobserveCb","handleNode","handleChange","prevProps","observeNode","threshold","rootMargin","trackVisibility","delay","unobserve","as","tag","useInView","triggerOnce","skip","initialInView","React","setRef","result","IntersectionObserverEntry","intersectionRatio","startDoc","doc","frame","getFrameElement","ownerDocument","registry","crossOriginUpdater","crossOriginRect","THROTTLE_TIMEOUT","POLL_INTERVAL","USE_MUTATION_OBSERVER","_setupCrossOriginUpdater","boundingClientRect","intersectionRect","convertFromParentRect","bottom","right","width","height","_checkForIntersections","_resetCrossOriginUpdater","target","_observationTargets","item","Error","_registerInstance","_monitorIntersections","_unmonitorIntersections","_unregisterInstance","disconnect","_unmonitorAllIntersections","takeRecords","records","_queuedEntries","_initThresholds","opt_threshold","t","isNaN","_parseRootMargin","opt_rootMargin","margins","split","margin","parts","exec","parseFloat","unit","win","defaultView","_monitoringDocuments","monitoringInterval","domObserver","setInterval","addEvent","MutationObserver","childList","characterData","subtree","_monitoringUnsubscribes","clearInterval","removeEvent","rootDoc","itemDoc","unsubscribe","unsubscribes","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","targetRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","time","rootBounds","_hasCrossedThreshold","isIntersecting","_callback","display","getParentNode","atRoot","parentRect","parentComputedStyle","frameRect","frameIntersect","overflow","computeRectIntersection","html","_expandRectByRootMargin","rect","_rootMarginValues","newRect","oldRatio","newRatio","containsDeep","frameElement","ensureDOMRect","targetArea","intersectionArea","Number","toFixed","opt_options","timer","throttle","opt_useCapture","attachEvent","detatchEvent","rect1","rect2","max","min","parentBoundingRect","parentIntersectionRect","assignedSlot"],"mappings":"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","file":"static/js/2.1f133fd2.chunk.js","sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError,\n\t_vnodeId: 0\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++options._vnodeId : original\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst ONCHANGE_INPUT_TYPES =\n\ttypeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\tlet normalizedProps = props;\n\n\t// only normalize props on Element nodes\n\tif (typeof type === 'string') {\n\t\tnormalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!ONCHANGE_INPUT_TYPES.test(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (type && props.class != props.className) {\n\t\tclassNameDescriptor.enumerable = 'className' in props;\n\t\tif (props.className != null) normalizedProps.class = props.className;\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value || (newVNode.type === 'progress' && !i))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","// import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tconst wasHydrating = vnode._hydrating;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\tvnode._hydrating = wasHydrating;\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { options, Fragment } from 'preact';\n\n/** @typedef {import('preact').VNode} VNode */\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {string} [__source]\n * @param {string} [__self]\n */\nfunction createVNode(type, props, key, __source, __self) {\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref: props && props.ref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: ++options._vnodeId,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tlet defaults, i;\n\tif (typeof type === 'function' && (defaults = type.defaultProps)) {\n\t\tfor (i in defaults) if (props[i] === undefined) props[i] = defaults[i];\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment\n};\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tconst wasHydrating = suspendingVNode._hydrating === true;\n\tif (!wasHydrating && !c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._hydrating = null;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","export * from 'preact/jsx-runtime';\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","import { ObserverInstanceCallback } from './index';\n\nconst ObserverMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: Map<Element, string> = new Map();\n\nlet rootId = 0;\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter((key) => options[key] !== undefined)\n    .map((key) => {\n      return `${key}_${\n        key === 'root' ? getRootId(options.root) : options[key]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = ObserverMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-ignore support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    ObserverMap.set(id, instance);\n  }\n\n  return instance;\n}\n\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  if (!element) return () => {};\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  let callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      ObserverMap.delete(id);\n    }\n  };\n}\n","import * as React from 'react';\nimport { IntersectionObserverProps, PlainChildrenProps } from './index';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function';\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  static displayName = 'InView';\n  static defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n    initialInView: false,\n  };\n\n  constructor(props: IntersectionObserverProps | PlainChildrenProps) {\n    super(props);\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined,\n    };\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip ||\n      prevProps.trackVisibility !== this.props.trackVisibility ||\n      prevProps.delay !== this.props.delay\n    ) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  node: Element | null = null;\n  _unobserveCb: (() => void) | null = null;\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const { threshold, root, rootMargin, trackVisibility, delay } = this.props;\n\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay,\n    });\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      // Clear the old observer, before we start observing a new element\n      this.unobserve();\n\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        // Reset the state if we get a new node, and we aren't ignoring updates\n        this.setState({ inView: !!this.props.initialInView, entry: undefined });\n      }\n    }\n    this.node = node ? node : null;\n    this.observeNode();\n  };\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    if (inView && this.props.triggerOnce) {\n      // If `triggerOnce` is true, we should stop observing the element.\n      this.unobserve();\n    }\n    if (!isPlainChildren(this.props)) {\n      // Store the current State, so we can pass it to the children in the next render update\n      // There's no reason to update the state for plain children, since it's not used in the rendering.\n      this.setState({ inView, entry });\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry);\n    }\n  };\n\n  render() {\n    if (!isPlainChildren(this.props)) {\n      const { inView, entry } = this.state;\n      return this.props.children({ inView, entry, ref: this.handleNode });\n    }\n\n    const {\n      children,\n      as,\n      tag,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      skip,\n      trackVisibility,\n      delay,\n      initialInView,\n      ...props\n    } = this.props;\n\n    return React.createElement(\n      as || tag || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    );\n  }\n}\n","import * as React from 'react';\nimport { InViewHookResponse, IntersectionOptions } from './index';\nimport { useEffect } from 'react';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nexport function useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n}: IntersectionOptions = {}): InViewHookResponse {\n  const unobserve = React.useRef<Function>();\n  const [state, setState] = React.useState<State>({\n    inView: !!initialInView,\n  });\n\n  const setRef = React.useCallback(\n    (node) => {\n      if (unobserve.current !== undefined) {\n        unobserve.current();\n        unobserve.current = undefined;\n      }\n\n      // Skip creating the observer\n      if (skip) return;\n\n      if (node) {\n        unobserve.current = observe(\n          node,\n          (inView, entry) => {\n            setState({ inView, entry });\n\n            if (entry.isIntersecting && triggerOnce && unobserve.current) {\n              // If it should only trigger once, unobserve the element after it's inView\n              unobserve.current();\n              unobserve.current = undefined;\n            }\n          },\n          {\n            root,\n            rootMargin,\n            threshold,\n            // @ts-ignore\n            trackVisibility,\n            // @ts-ignore\n            delay,\n          },\n        );\n      }\n    },\n    // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // If the threshold is an array, convert it to a string so it won't change between renders.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      trackVisibility,\n      delay,\n    ],\n  );\n\n  /* eslint-disable-next-line */\n  useEffect(() => {\n    if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView,\n      });\n    }\n  });\n\n  const result = [setRef, state.inView, state.entry] as InViewHookResponse;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function() {\n'use strict';\n\n// Exit early if we're not running in a browser.\nif (typeof window !== 'object') {\n  return;\n}\n\n// Exit early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\n  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n      'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  return;\n}\n\n/**\n * Returns the embedding frame element, if any.\n * @param {!Document} doc\n * @return {!Element}\n */\nfunction getFrameElement(doc) {\n  try {\n    return doc.defaultView && doc.defaultView.frameElement || null;\n  } catch (e) {\n    // Ignore the error.\n    return null;\n  }\n}\n\n/**\n * A local reference to the root document.\n */\nvar document = (function(startDoc) {\n  var doc = startDoc;\n  var frame = getFrameElement(doc);\n  while (frame) {\n    doc = frame.ownerDocument;\n    frame = getFrameElement(doc);\n  }\n  return doc;\n})(window.document);\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observing a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n/**\n * The signal updater for cross-origin intersection. When not null, it means\n * that the polyfill is configured to work in a cross-origin mode.\n * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nvar crossOriginUpdater = null;\n\n/**\n * The current cross-origin intersection. Only used in the cross-origin mode.\n * @type {DOMRect|ClientRect}\n */\nvar crossOriginRect = null;\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = ensureDOMRect(entry.rootBounds);\n  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);\n  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    // Round the intersection ratio to avoid floating point math issues:\n    // https://github.com/w3c/IntersectionObserver/issues/324\n    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (options.root && options.root.nodeType != 1) {\n    throw new Error('root must be an Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n\n  /** @private @const {!Array<!Document>} */\n  this._monitoringDocuments = [];\n  /** @private @const {!Array<function()>} */\n  this._monitoringUnsubscribes = [];\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Sets up the polyfill in the cross-origin mode. The result is the\n * updater function that accepts two arguments: `boundingClientRect` and\n * `intersectionRect` - just as these fields would be available to the\n * parent via `IntersectionObserverEntry`. This function should be called\n * each time the iframe receives intersection information from the parent\n * window, e.g. via messaging.\n * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nIntersectionObserver._setupCrossOriginUpdater = function() {\n  if (!crossOriginUpdater) {\n    /**\n     * @param {DOMRect|ClientRect} boundingClientRect\n     * @param {DOMRect|ClientRect} intersectionRect\n     */\n    crossOriginUpdater = function(boundingClientRect, intersectionRect) {\n      if (!boundingClientRect || !intersectionRect) {\n        crossOriginRect = getEmptyRect();\n      } else {\n        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);\n      }\n      registry.forEach(function(observer) {\n        observer._checkForIntersections();\n      });\n    };\n  }\n  return crossOriginUpdater;\n};\n\n\n/**\n * Resets the cross-origin mode.\n */\nIntersectionObserver._resetCrossOriginUpdater = function() {\n  crossOriginUpdater = null;\n  crossOriginRect = null;\n};\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections(target.ownerDocument);\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n        return item.element != target;\n      });\n  this._unmonitorIntersections(target.ownerDocument);\n  if (this._observationTargets.length == 0) {\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorAllIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibility state is visible.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function(doc) {\n  var win = doc.defaultView;\n  if (!win) {\n    // Already destroyed.\n    return;\n  }\n  if (this._monitoringDocuments.indexOf(doc) != -1) {\n    // Already monitoring.\n    return;\n  }\n\n  // Private state for monitoring.\n  var callback = this._checkForIntersections;\n  var monitoringInterval = null;\n  var domObserver = null;\n\n  // If a poll interval is set, use polling instead of listening to\n  // resize and scroll events or DOM mutations.\n  if (this.POLL_INTERVAL) {\n    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);\n  } else {\n    addEvent(win, 'resize', callback, true);\n    addEvent(doc, 'scroll', callback, true);\n    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {\n      domObserver = new win.MutationObserver(callback);\n      domObserver.observe(doc, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    }\n  }\n\n  this._monitoringDocuments.push(doc);\n  this._monitoringUnsubscribes.push(function() {\n    // Get the window object again. When a friendly iframe is destroyed, it\n    // will be null.\n    var win = doc.defaultView;\n\n    if (win) {\n      if (monitoringInterval) {\n        win.clearInterval(monitoringInterval);\n      }\n      removeEvent(win, 'resize', callback, true);\n    }\n\n    removeEvent(doc, 'scroll', callback, true);\n    if (domObserver) {\n      domObserver.disconnect();\n    }\n  });\n\n  // Also monitor the parent.\n  if (doc != (this.root && this.root.ownerDocument || document)) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._monitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function(doc) {\n  var index = this._monitoringDocuments.indexOf(doc);\n  if (index == -1) {\n    return;\n  }\n\n  var rootDoc = (this.root && this.root.ownerDocument || document);\n\n  // Check if any dependent targets are still remaining.\n  var hasDependentTargets =\n      this._observationTargets.some(function(item) {\n        var itemDoc = item.element.ownerDocument;\n        // Target is in this context.\n        if (itemDoc == doc) {\n          return true;\n        }\n        // Target is nested in this context.\n        while (itemDoc && itemDoc != rootDoc) {\n          var frame = getFrameElement(itemDoc);\n          itemDoc = frame && frame.ownerDocument;\n          if (itemDoc == doc) {\n            return true;\n          }\n        }\n        return false;\n      });\n  if (hasDependentTargets) {\n    return;\n  }\n\n  // Unsubscribe.\n  var unsubscribe = this._monitoringUnsubscribes[index];\n  this._monitoringDocuments.splice(index, 1);\n  this._monitoringUnsubscribes.splice(index, 1);\n  unsubscribe();\n\n  // Also unmonitor the parent.\n  if (doc != rootDoc) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._unmonitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorAllIntersections = function() {\n  var unsubscribes = this._monitoringUnsubscribes.slice(0);\n  this._monitoringDocuments.length = 0;\n  this._monitoringUnsubscribes.length = 0;\n  for (var i = 0; i < unsubscribes.length; i++) {\n    unsubscribes[i]();\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  if (!this.root && crossOriginUpdater && !crossOriginRect) {\n    // Cross origin monitoring, but no initial data available yet.\n    return;\n  }\n\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, targetRect, rootRect);\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: crossOriginUpdater && !this.root ? null : rootRect,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} targetRect The bounding rect of the target.\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, targetRect, rootRect) {\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot && parent) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return null;\n\n    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {\n      atRoot = true;\n      if (parent == this.root || parent == document) {\n        if (crossOriginUpdater && !this.root) {\n          if (!crossOriginRect ||\n              crossOriginRect.width == 0 && crossOriginRect.height == 0) {\n            // A 0-size cross-origin intersection means no-intersection.\n            parent = null;\n            parentRect = null;\n            intersectionRect = null;\n          } else {\n            parentRect = crossOriginRect;\n          }\n        } else {\n          parentRect = rootRect;\n        }\n      } else {\n        // Check if there's a frame that can be navigated to.\n        var frame = getParentNode(parent);\n        var frameRect = frame && getBoundingClientRect(frame);\n        var frameIntersect =\n            frame &&\n            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);\n        if (frameRect && frameIntersect) {\n          parent = frame;\n          parentRect = convertFromParentRect(frameRect, frameIntersect);\n        } else {\n          parent = null;\n          intersectionRect = null;\n        }\n      }\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      var doc = parent.ownerDocument;\n      if (parent != doc.body &&\n          parent != doc.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n    }\n    if (!intersectionRect) break;\n    parent = parent && getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {ClientRect} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var html = document.documentElement;\n    var body = document.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {DOMRect|ClientRect} rect The rect object to expand.\n * @return {ClientRect} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  return containsDeep(this.root || document, target) &&\n    (!this.root || this.root.ownerDocument == target.ownerDocument);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object|?ClientRect} The intersection rect or undefined if no\n *     intersection is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  } || null;\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {ClientRect} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n\n/**\n * Ensure that the result has all of the necessary fields of the DOMRect.\n * Specifically this ensures that `x` and `y` fields are set.\n *\n * @param {?DOMRect|?ClientRect} rect\n * @return {?DOMRect}\n */\nfunction ensureDOMRect(rect) {\n  // A `DOMRect` object has `x` and `y` fields.\n  if (!rect || 'x' in rect) {\n    return rect;\n  }\n  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case\n  // for internally calculated Rect objects. For the purposes of\n  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`\n  // for these fields.\n  return {\n    top: rect.top,\n    y: rect.top,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    right: rect.right,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n\n/**\n * Inverts the intersection and bounding rect from the parent (frame) BCR to\n * the local BCR space.\n * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.\n * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.\n * @return {ClientRect} The local root bounding rect for the parent's children.\n */\nfunction convertFromParentRect(parentBoundingRect, parentIntersectionRect) {\n  var top = parentIntersectionRect.top - parentBoundingRect.top;\n  var left = parentIntersectionRect.left - parentBoundingRect.left;\n  return {\n    top: top,\n    left: left,\n    height: parentIntersectionRect.height,\n    width: parentIntersectionRect.width,\n    bottom: top + parentIntersectionRect.height,\n    right: left + parentIntersectionRect.width\n  };\n}\n\n\n/**\n * Checks to see if a parent element contains a child element (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {\n    // If this node is a document node, look for the embedding frame.\n    return getFrameElement(node);\n  }\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n\n  if (parent && parent.assignedSlot) {\n    // If the parent is distributed in a <slot>, return the parent of a slot.\n    return parent.assignedSlot.parentNode;\n  }\n\n  return parent;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}());\n"],"sourceRoot":""}